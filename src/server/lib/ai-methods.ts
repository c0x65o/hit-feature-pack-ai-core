import fs from 'node:fs';
import path from 'node:path';

export type CapabilityEndpoint = {
  pathTemplate: string;
  methods: string[];
  summary?: string;
  methodDocs?: Record<string, string>;
  requiredBodyFields?: Record<string, string[]>;
  bodyFields?: Record<string, string[]>;
  queryParams?: string[];
  // Filled by hit-cli for endpoints sourced from feature packs.
  _featurePack?: string;
  // Optional schemas generated by hit-cli (Zod -> JSON Schema)
  // Stored as method -> jsonSchema mappings (e.g., { "POST": {..} })
  jsonSchema?: Record<string, any>;
  querySchema?: Record<string, any>;
  responseSchema?: Record<string, any>;
};

export type CapabilitiesFile = {
  generated?: boolean;
  kind?: string;
  endpoints?: CapabilityEndpoint[];
};

export type MethodSpec = {
  name: string;
  method: string;
  pathTemplate: string;
  description: string;
  pathParams: string[];
  requiredBodyFields?: string[];
  bodyFields?: string[];
  queryParams?: string[];
  // Per-method schemas (already indexed by method)
  jsonSchema?: any;
  querySchema?: any;
  responseSchema?: any;
  readOnly: boolean;
  /**
   * Optional feature pack name that "owns" this endpoint.
   * Populated from capabilities endpoint `_featurePack` (hit-cli generated).
   */
  featurePack?: string;
};

function extractPathParams(pathTemplate: string): string[] {
  const params: string[] = [];
  const re = /\[([^\]]+)\]/g;
  let m: RegExpExecArray | null = null;
  while ((m = re.exec(pathTemplate))) {
    if (m[1]) params.push(m[1]);
  }
  return params;
}

export function methodNameFor(pathTemplate: string, method: string): string {
  const cleaned = pathTemplate
    .replace(/^\//, '')
    .replace(/\[([^\]]+)\]/g, '$1')
    .replace(/[^a-zA-Z0-9]+/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '')
    .toLowerCase();
  const m = method.toUpperCase();
  return `route_${cleaned}__${m}`;
}

export function loadCapabilitiesFromDisk(projectRoot: string): CapabilitiesFile | null {
  const capsPath = path.join(projectRoot, '.hit', 'generated', 'capabilities.json');
  if (!fs.existsSync(capsPath)) return null;
  try {
    const raw = fs.readFileSync(capsPath, 'utf8');
    return JSON.parse(raw) as CapabilitiesFile;
  } catch {
    return null;
  }
}

export function buildMethodCatalog(caps: CapabilitiesFile): MethodSpec[] {
  const endpoints = Array.isArray(caps.endpoints) ? caps.endpoints : [];
  const out: MethodSpec[] = [];

  for (const ep of endpoints) {
    const methods = Array.isArray(ep.methods) ? ep.methods : [];
    for (const method of methods) {
      const m = String(method || '').toUpperCase();
      if (!m) continue;
      const doc = ep.methodDocs?.[m] || ep.summary || '';
      const desc = `${m} ${ep.pathTemplate}${doc ? ` â€” ${doc}` : ''}`.trim();
      const requiredBodyFields = Array.isArray(ep.requiredBodyFields?.[m]) ? ep.requiredBodyFields?.[m] : undefined;
      const bodyFields = Array.isArray(ep.bodyFields?.[m]) ? ep.bodyFields?.[m] : undefined;
      const queryParams = Array.isArray(ep.queryParams) ? ep.queryParams : undefined;
      const jsonSchema = ep.jsonSchema && typeof ep.jsonSchema === 'object' ? (ep.jsonSchema as any)[m] : undefined;
      const querySchema = ep.querySchema && typeof ep.querySchema === 'object' ? (ep.querySchema as any)[m] : undefined;
      const responseSchema = ep.responseSchema && typeof ep.responseSchema === 'object' ? (ep.responseSchema as any)[m] : undefined;
      out.push({
        name: methodNameFor(ep.pathTemplate, m),
        method: m,
        pathTemplate: ep.pathTemplate,
        description: desc,
        pathParams: extractPathParams(ep.pathTemplate),
        requiredBodyFields,
        bodyFields,
        queryParams,
        jsonSchema,
        querySchema,
        responseSchema,
        readOnly: m === 'GET',
        featurePack: typeof ep._featurePack === 'string' && ep._featurePack.trim() ? ep._featurePack.trim() : undefined,
      });
    }
  }

  out.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));
  return out;
}



